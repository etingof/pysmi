* add more tests on edge cases
* generate reverse OID -> MIB index
* handle SMIv1 MAX clause in range constraint
* support MAX clause mapping it into type-specific value
* possibly add additional AST processing phase to resolve imported symbols
  in a more consistent way
* support more common broken SMI constructs 
* DEFVAL and AUGMENTS should not depend on the order of symbols in MIB
* make a collection of fixed MIBs (e.g. Huawei has lots of bad/broken MIBs)
* some MIBs use hex as DEFVAL for types other than OCTET STRING (additional AST processing phase will help)
* handle the case when the symbol and the enumaration value (which can be in DEFVAL) have the same name - llc2 in NETLINK-SPECIFIC-MIB (additional AST processing phase will help)
* check imports and try to add necessary ones if missed (like OBJECT-TYPE, MODULE-IDENTITY, etc)
* generate TextualConvention first or add additional AST processing phase
* implement a cache of available files at abstract reader path
* create a command-line tool for splitting MIBs stored in a single file
* create a MIB querying tool: get MIB module's OIDs, enterprise IDs,
  canonical name(s); search MIB objects by regexp; build source .index
* implement xml/html/json/yaml codegeneration backend
* figure out how to reuse a single Ply lexer/parser instrance rather than
  recreating new ones on each invocation
